# 탈출구

## useRef

1. Refs는 렌더링에 사용되지 않는 값을 고정하기 위한 탈출구이며, 자주 필요하지는 않습니다.
2. ref는 읽거나 설정할 수 있는 current라는 프로퍼티를 호출할 수 있는 자바스크립트 순수객체입니다.
3. useRef Hook을 호출해 ref를 달라고 React에 요청할 수 있습니다.
4. state와 마찬가지로 ref는 컴포넌트의 렌더링 간에 정보를 유지할 수 있습니다.
5. state와 달리 ref의 current 값을 설정하면 리렌더가 트리거되지 않습니다.
6. 렌더링 중에 ref.current를 읽거나 쓰지 마세요.

```
// useRef를 state로 구현한다면
function useRef(initialValue) {
const [ref, unused] = useState({ current: initialValue });
return ref;
}
```

## useEffect

```
useEffect는 화면에 렌더링이 반영될 때까지 코드 실행을 “지연”시킵니다.
```

Effect는 일반적으로 컴포넌트를 외부 시스템과 동기화하는 데 사용

1. 이벤트와 달리 Effect는 특정 상호작용이 아닌 렌더링 자체에 의해 발생합니다.
2. Effect를 사용하면 컴포넌트를 외부 시스템(타사 API, 네트워크 등)과 동기화할 수 있습니다.
3. 기본적으로 Effect는 모든 렌더링(초기 렌더링 포함) 후에 실행됩니다.
4. React는 모든 의존성이 마지막 렌더링과 동일한 값을 가지면 Effect를 건너뜁니다.
5. 의존성을 “선택”할 수 없습니다. 의존성은 Effect 내부의 코드에 의해 결정됩니다.
6. 빈 의존성 배열([])은 컴포넌트 “마운팅”(화면에 추가됨)을 의미합니다.
7. Strict Mode에서 React는 컴포넌트를 두 번 마운트합니다(개발 환경에서만!) 이는 Effect의 스트레스 테스트를 위한 것입니다.
8. Effect가 다시 마운트로 인해 중단된 경우 클린업 함수를 구현해야 합니다.
9. React는 Effect가 다음에 실행되기 전에 정리 함수를 호출하며, 마운트 해제 중에도 호출합니다.

### useEffect가 필요없는 경우

1. 렌더링 중에 무언가를 계산할 수 있다면 Effect가 필요하지 않습니다.
2. 비용이 많이 드는 계산을 캐시하려면 useEffect 대신 useMemo를 추가하세요.
3. 전체 컴포넌트 트리의 state를 초기화하려면 다른 key를 전달하세요.
4. prop 변경에 대한 응답으로 특정 state bit를 초기화하려면 렌더링 중에 설정하세요.
5. 컴포넌트가 표시되어 실행되는 코드는 Effect에 있어야 하고 나머지는 이벤트에 있어야 합니다.
6. 여러 컴포넌트의 state를 업데이트해야 하는 경우 단일 이벤트 중에 수행하는 것이 좋습니다.
7. 다른 컴포넌트의 state 변수를 동기화하려고 할 때마다 state 끌어올리기를 고려하세요.
8. Effect로 데이터를 가져올 수 있지만 경쟁 조건을 피하기 위해 정리를 구현해야 합니다.

## useEffect 생명주기

각 effect는 주변 컴포넌트와 별도의 생명주기를 가집니다.
각 effect는 시작 및 중지할 수 있는 별도의 동기화 프로세스를 설명합니다.
effect를 작성하고 읽을 때는 컴포넌트의 관점(마운트, 업데이트 또는 마운트 해제 방법)이 아닌 개별 effect의 관점(동기화 시작 및 중지 방법)에서 생각하세요.
컴포넌트 본문 내부에 선언된 값은 “반응형”입니다.
반응형 값은 시간이 지남에 따라 변경될 수 있으므로 effect를 다시 동기화해야 합니다.
린터는 effect 내부에서 사용된 모든 반응형 값이 종속성으로 지정되었는지 확인합니다.
린터에 의해 플래그가 지정된 모든 오류는 합법적인 오류입니다. 규칙을 위반하지 않도록 코드를 수정할 방법은 항상 있습니다.
